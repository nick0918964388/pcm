#!/usr/bin/env node

import { program } from 'commander';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import {
  DatabaseConfig,
  ComparisonConfig,
  ComparisonReport,
  DatabaseConnection
} from './data-comparison.types';
import { DataComparisonService } from './data-comparison.service';

// PostgreSQL ÈÄ£Á∑öÂØ¶‰Ωú
class PostgreSQLConnection implements DatabaseConnection {
  private config: DatabaseConfig;
  private client: any = null;

  constructor(config: DatabaseConfig) {
    this.config = config;
  }

  async connect(): Promise<void> {
    try {
      const { Pool } = await import('pg');
      this.client = new Pool({
        host: this.config.host,
        port: this.config.port,
        database: this.config.database,
        user: this.config.username,
        password: this.config.password,
        ssl: false
      });
    } catch (error) {
      throw new Error(`Failed to connect to PostgreSQL: ${error}`);
    }
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      await this.client.end();
      this.client = null;
    }
  }

  async executeQuery(query: string, params?: any[]): Promise<any[]> {
    if (!this.client) {
      throw new Error('Database not connected');
    }

    try {
      const result = await this.client.query(query, params);
      return result.rows;
    } catch (error) {
      throw new Error(`Query execution failed: ${error}`);
    }
  }

  async getMetadata(tableName: string): Promise<any> {
    const query = `
      SELECT
        column_name as name,
        data_type as "dataType",
        is_nullable = 'YES' as "isNullable",
        column_default as "defaultValue",
        character_maximum_length as "characterMaxLength",
        numeric_precision as "numericPrecision",
        numeric_scale as "numericScale"
      FROM information_schema.columns
      WHERE table_name = $1
      ORDER BY ordinal_position
    `;

    const columns = await this.executeQuery(query, [tableName]);

    const pkQuery = `
      SELECT column_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
      WHERE tc.table_name = $1 AND tc.constraint_type = 'PRIMARY KEY'
    `;

    const pkResult = await this.executeQuery(pkQuery, [tableName]);
    const primaryKeys = pkResult.map(row => row.column_name);

    return {
      name: tableName,
      schema: 'public',
      columns,
      primaryKeys,
      indexes: []
    };
  }

  isConnected(): boolean {
    return this.client !== null;
  }
}

// Oracle ÈÄ£Á∑öÂØ¶‰Ωú
class OracleConnection implements DatabaseConnection {
  private config: DatabaseConfig;
  private connection: any = null;

  constructor(config: DatabaseConfig) {
    this.config = config;
  }

  async connect(): Promise<void> {
    try {
      const oracledb = await import('oracledb');
      this.connection = await oracledb.getConnection({
        user: this.config.username,
        password: this.config.password,
        connectString: `${this.config.host}:${this.config.port}/${this.config.database}`
      });
    } catch (error) {
      throw new Error(`Failed to connect to Oracle: ${error}`);
    }
  }

  async disconnect(): Promise<void> {
    if (this.connection) {
      await this.connection.close();
      this.connection = null;
    }
  }

  async executeQuery(query: string, params?: any[]): Promise<any[]> {
    if (!this.connection) {
      throw new Error('Database not connected');
    }

    try {
      const result = await this.connection.execute(query, params || [], {
        outFormat: 'OBJECT'
      });
      return result.rows;
    } catch (error) {
      throw new Error(`Query execution failed: ${error}`);
    }
  }

  async getMetadata(tableName: string): Promise<any> {
    const query = `
      SELECT
        COLUMN_NAME as name,
        DATA_TYPE as "dataType",
        CASE WHEN NULLABLE = 'Y' THEN 1 ELSE 0 END as "isNullable",
        DATA_DEFAULT as "defaultValue",
        DATA_LENGTH as "characterMaxLength",
        DATA_PRECISION as "numericPrecision",
        DATA_SCALE as "numericScale"
      FROM USER_TAB_COLUMNS
      WHERE TABLE_NAME = UPPER(:tableName)
      ORDER BY COLUMN_ID
    `;

    const columns = await this.executeQuery(query, [tableName]);

    const pkQuery = `
      SELECT COLUMN_NAME as column_name
      FROM USER_CONS_COLUMNS
      WHERE CONSTRAINT_NAME = (
        SELECT CONSTRAINT_NAME
        FROM USER_CONSTRAINTS
        WHERE TABLE_NAME = UPPER(:tableName) AND CONSTRAINT_TYPE = 'P'
      )
    `;

    const pkResult = await this.executeQuery(pkQuery, [tableName]);
    const primaryKeys = pkResult.map(row => row.column_name);

    return {
      name: tableName,
      schema: this.config.schema || 'public',
      columns,
      primaryKeys,
      indexes: []
    };
  }

  isConnected(): boolean {
    return this.connection !== null;
  }
}

// ÈÖçÁΩÆÊ™îÊ°àËºâÂÖ•
function loadConfig(configPath: string): ComparisonConfig {
  try {
    const configData = readFileSync(configPath, 'utf-8');
    return JSON.parse(configData);
  } catch (error) {
    throw new Error(`Failed to load config file: ${error}`);
  }
}

// ÁµêÊûúÂÑ≤Â≠ò
function saveResults(report: ComparisonReport, outputPath: string, format: string): void {
  let content: string;

  switch (format.toLowerCase()) {
    case 'json':
      content = JSON.stringify(report, null, 2);
      break;
    case 'txt':
      content = generateTextReport(report);
      break;
    default:
      throw new Error(`Unsupported output format: ${format}`);
  }

  writeFileSync(outputPath, content, 'utf-8');
}

// ÊñáÂ≠óÂ†±ÂëäÁîüÊàê
function generateTextReport(report: ComparisonReport): string {
  const lines: string[] = [];

  lines.push('='.repeat(80));
  lines.push('Ë≥áÊñôÊØîÂ∞çÂ†±Âëä');
  lines.push('='.repeat(80));
  lines.push(`Âü∑Ë°åÊôÇÈñì: ${report.timestamp.toISOString()}`);
  lines.push(`Âü∑Ë°å ID: ${report.executionId}`);
  lines.push(`Á∏ΩËÄóÊôÇ: ${report.executionTime}ms`);
  lines.push('');

  // ÊëòË¶Å
  lines.push('ÊëòË¶Å');
  lines.push('-'.repeat(40));
  lines.push(`Á∏ΩË°®Ê†ºÊï∏: ${report.summary.totalTables}`);
  lines.push(`Ë®àÊï∏‰∏çÂåπÈÖç: ${report.summary.tablesWithCountMismatch}`);
  lines.push(`ÂÖßÂÆπÂ∑ÆÁï∞: ${report.summary.tablesWithContentDifferences}`);
  lines.push(`ÁµêÊßãÂ∑ÆÁï∞: ${report.summary.tablesWithStructureDifferences}`);
  lines.push(`Ë≥áÊñôÂÆåÊï¥ÊÄß: ${report.summary.overallDataIntegrity.toFixed(2)}%`);
  lines.push('');

  // Ë©≥Á¥∞ÁµêÊûú
  if (report.countResults.length > 0) {
    lines.push('Ë°®Ê†ºË®àÊï∏ÊØîÂ∞ç');
    lines.push('-'.repeat(40));
    for (const result of report.countResults) {
      const status = result.countMatch ? '‚úì' : '‚úó';
      lines.push(`${status} ${result.tableName}: ${result.sourceCount} -> ${result.targetCount}`);
      if (!result.countMatch) {
        lines.push(`  Â∑ÆÁï∞: ${result.difference} (${result.percentageDiff.toFixed(2)}%)`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

// ‰∏ªÁ®ãÂºè
async function main() {
  program
    .name('data-comparison')
    .description('PCM Ë≥áÊñôÂ∫´ÊØîÂ∞çÂ∑•ÂÖ∑')
    .version('1.0.0');

  program
    .command('compare')
    .description('Âü∑Ë°åË≥áÊñôÂ∫´ÊØîÂ∞ç')
    .option('-c, --config <path>', 'ÈÖçÁΩÆÊ™îÊ°àË∑ØÂæë', './comparison-config.json')
    .option('-o, --output <path>', 'Ëº∏Âá∫Ê™îÊ°àË∑ØÂæë', './comparison-report.json')
    .option('-f, --format <format>', 'Ëº∏Âá∫Ê†ºÂºè (json|txt)', 'json')
    .option('--tables <tables>', 'ÊåáÂÆöË¶ÅÊØîÂ∞çÁöÑË°®Ê†º (ÈÄóËôüÂàÜÈöî)')
    .option('--count-only', 'Âè™Âü∑Ë°åË®àÊï∏ÊØîÂ∞ç')
    .option('--content-only', 'Âè™Âü∑Ë°åÂÖßÂÆπÊØîÂ∞ç')
    .option('--structure-only', 'Âè™Âü∑Ë°åÁµêÊßãÊØîÂ∞ç')
    .action(async (options) => {
      try {
        console.log('üîç ÈñãÂßãË≥áÊñôÂ∫´ÊØîÂ∞ç...');

        // ËºâÂÖ•ÈÖçÁΩÆ
        const config = loadConfig(options.config);

        // Â¶ÇÊûúÊåáÂÆö‰∫ÜË°®Ê†ºÔºåË¶ÜËìãÈÖçÁΩÆ
        if (options.tables) {
          config.tables = options.tables.split(',').map((t: string) => t.trim());
        }

        // Âª∫Á´ãÈÄ£Á∑ö
        const sourceConnection = config.sourceDb.type === 'postgresql'
          ? new PostgreSQLConnection(config.sourceDb)
          : new OracleConnection(config.sourceDb);

        const targetConnection = config.targetDb.type === 'postgresql'
          ? new PostgreSQLConnection(config.targetDb)
          : new OracleConnection(config.targetDb);

        // Âª∫Á´ãÊØîÂ∞çÊúçÂãô
        const comparisonTool = new DataComparisonService(sourceConnection, targetConnection);

        let report: ComparisonReport;

        if (options.countOnly || options.contentOnly || options.structureOnly) {
          // Âü∑Ë°åÈÉ®ÂàÜÊØîÂ∞ç
          await sourceConnection.connect();
          await targetConnection.connect();

          const countResults = options.countOnly ? await comparisonTool.compareTableCounts(config.tables) : [];
          const contentResults = options.contentOnly ? await comparisonTool.compareTableContent(config.tables) : [];
          const structureResults = options.structureOnly ? await comparisonTool.compareTableStructure(config.tables) : [];

          report = {
            executionId: `partial_${Date.now()}`,
            timestamp: new Date(),
            config,
            summary: {
              totalTables: config.tables.length,
              tablesWithCountMismatch: countResults.filter(r => !r.countMatch).length,
              tablesWithContentDifferences: contentResults.filter(r => r.exactMatches < r.totalRecords).length,
              tablesWithStructureDifferences: structureResults.filter(r => !r.structureMatch).length,
              overallDataIntegrity: 100,
              criticalIssues: 0,
              warnings: 0
            },
            countResults,
            contentResults,
            structureResults,
            errors: [],
            executionTime: 0
          };

          await sourceConnection.disconnect();
          await targetConnection.disconnect();
        } else {
          // Âü∑Ë°åÂÆåÊï¥ÊØîÂ∞ç
          report = await comparisonTool.performFullComparison(config);
        }

        // ÂÑ≤Â≠òÁµêÊûú
        saveResults(report, options.output, options.format);

        // È°ØÁ§∫ÊëòË¶Å
        console.log(`‚úÖ ÊØîÂ∞çÂÆåÊàêÔºÅ`);
        console.log(`üìä Á∏ΩË°®Ê†ºÊï∏: ${report.summary.totalTables}`);
        console.log(`‚ö†Ô∏è  Ë®àÊï∏‰∏çÂåπÈÖç: ${report.summary.tablesWithCountMismatch}`);
        console.log(`üìà Ë≥áÊñôÂÆåÊï¥ÊÄß: ${report.summary.overallDataIntegrity.toFixed(2)}%`);
        console.log(`üíæ ÁµêÊûúÂ∑≤ÂÑ≤Â≠òËá≥: ${options.output}`);

        if (report.summary.tablesWithCountMismatch > 0) {
          process.exit(1);
        }

      } catch (error) {
        console.error(`‚ùå ÈåØË™§: ${error}`);
        process.exit(1);
      }
    });

  program
    .command('init')
    .description('Âª∫Á´ãÈ†êË®≠ÈÖçÁΩÆÊ™îÊ°à')
    .option('-o, --output <path>', 'ÈÖçÁΩÆÊ™îÊ°àË∑ØÂæë', './comparison-config.json')
    .action((options) => {
      const defaultConfig: ComparisonConfig = {
        sourceDb: {
          type: 'postgresql',
          host: 'localhost',
          port: 5432,
          database: 'pcm_source',
          username: 'postgres',
          password: 'password'
        },
        targetDb: {
          type: 'oracle',
          host: 'localhost',
          port: 1521,
          database: 'XE',
          username: 'pcm',
          password: 'password'
        },
        tables: [
          'users',
          'projects',
          'project_members',
          'wbs_items',
          'vendors',
          'duty_schedules'
        ],
        excludeColumns: ['created_at', 'updated_at'],
        includeSystemTables: false,
        maxSampleSize: 1000,
        batchSize: 100
      };

      writeFileSync(options.output, JSON.stringify(defaultConfig, null, 2), 'utf-8');
      console.log(`‚úÖ È†êË®≠ÈÖçÁΩÆÊ™îÊ°àÂ∑≤Âª∫Á´ã: ${options.output}`);
      console.log('üìù Ë´ãÁ∑®ËºØÈÖçÁΩÆÊ™îÊ°à‰ª•Á¨¶ÂêàÊÇ®ÁöÑÁí∞Â¢ÉË®≠ÂÆö');
    });

  await program.parseAsync(process.argv);
}

// ÈåØË™§ËôïÁêÜ
process.on('unhandledRejection', (error) => {
  console.error('‚ùå Êú™ËôïÁêÜÁöÑ Promise ÊãíÁµï:', error);
  process.exit(1);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Êú™ÊçïÁç≤ÁöÑ‰æãÂ§ñ:', error);
  process.exit(1);
});

// Âü∑Ë°å‰∏ªÁ®ãÂºè
if (require.main === module) {
  main().catch(console.error);
}

export { main };