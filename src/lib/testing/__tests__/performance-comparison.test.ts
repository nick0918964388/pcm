import { describe, it, expect, beforeAll, afterAll } from 'vitest';

// Performance Comparison Tests between PostgreSQL and Oracle
// PostgreSQL與Oracle效能比較測試

interface DatabasePerformanceResult {
  database: 'postgresql' | 'oracle';
  queryType: string;
  executionTime: number;
  cpuTime: number;
  memoryUsage: number;
  ioOperations: number;
  rowsProcessed: number;
  planComplexity: number;
  indexesUsed: string[];
  connectionTime: number;
}

interface PerformanceComparison {
  queryType: string;
  postgresqlResult: DatabasePerformanceResult;
  oracleResult: DatabasePerformanceResult;
  performanceRatio: number; // Oracle time / PostgreSQL time
  recommendation: string;
  meetsBenchmark: boolean;
}

interface DatabaseConnection {
  type: 'postgresql' | 'oracle';
  query: (sql: string, params?: any[]) => Promise<any[]>;
  getExecutionPlan: (sql: string) => Promise<any[]>;
  getConnectionInfo: () => Promise<any>;
  close: () => Promise<void>;
}

describe('PostgreSQL vs Oracle Performance Comparison', () => {
  let postgresConnection: DatabaseConnection;
  let oracleConnection: DatabaseConnection;
  let testDataSize: number;

  beforeAll(async () => {
    console.log('Setting up database performance comparison environment...');
    testDataSize = 50000; // 50k records for meaningful comparison

    // RED: This will fail until dual database connections are implemented
    postgresConnection = await createDatabaseConnection('postgresql');
    oracleConnection = await createDatabaseConnection('oracle');

    // Ensure both databases have identical test data
    await setupTestData(postgresConnection, testDataSize);
    await setupTestData(oracleConnection, testDataSize);
  });

  afterAll(async () => {
    console.log('Cleaning up performance comparison environment...');
    await postgresConnection?.close();
    await oracleConnection?.close();
  });

  async function createDatabaseConnection(type: 'postgresql' | 'oracle'): Promise<DatabaseConnection> {
    // RED: This will fail until database abstraction layer is implemented
    if (type === 'postgresql') {
      const pgConnection = await import('../../../lib/database/postgresql-connection');
      return {
        type: 'postgresql',
        query: pgConnection.query,
        getExecutionPlan: pgConnection.getExecutionPlan,
        getConnectionInfo: pgConnection.getConnectionInfo,
        close: pgConnection.close
      };
    } else {
      const oracleConnection = await import('../../../lib/database/oracle-connection');
      return {
        type: 'oracle',
        query: oracleConnection.query,
        getExecutionPlan: oracleConnection.getExecutionPlan,
        getConnectionInfo: oracleConnection.getConnectionInfo,
        close: oracleConnection.close
      };
    }
  }

  async function setupTestData(connection: DatabaseConnection, size: number): Promise<void> {
    // Create identical test datasets in both databases
    const tableCreationQueries = connection.type === 'postgresql' ? [
      `CREATE TABLE IF NOT EXISTS perf_test_projects (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'active',
        priority INTEGER DEFAULT 3,
        metadata JSONB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      `CREATE INDEX IF NOT EXISTS idx_perf_projects_status ON perf_test_projects(status)`,
      `CREATE INDEX IF NOT EXISTS idx_perf_projects_created ON perf_test_projects(created_at)`,
      `CREATE INDEX IF NOT EXISTS idx_perf_projects_metadata ON perf_test_projects USING GIN(metadata)`
    ] : [
      `CREATE TABLE perf_test_projects (
        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR2(255) NOT NULL,
        description CLOB,
        status VARCHAR2(50) DEFAULT 'active',
        priority NUMBER DEFAULT 3,
        metadata CLOB CHECK (metadata IS JSON),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      `CREATE INDEX idx_perf_projects_status ON perf_test_projects(status)`,
      `CREATE INDEX idx_perf_projects_created ON perf_test_projects(created_at)`,
      `CREATE INDEX idx_perf_projects_metadata ON perf_test_projects(JSON_VALUE(metadata, '$'))`
    ];

    for (const query of tableCreationQueries) {
      try {
        await connection.query(query);
      } catch (error) {
        // Table might already exist
      }
    }

    // Insert test data
    const batchSize = 1000;
    for (let i = 0; i < size; i += batchSize) {
      const values = [];
      for (let j = 0; j < batchSize && (i + j) < size; j++) {
        const recordNum = i + j + 1;
        const metadata = JSON.stringify({
          category: `category_${recordNum % 10}`,
          tags: [`tag_${recordNum % 5}`, `tag_${recordNum % 7}`],
          priority: recordNum % 5 + 1,
          version: '1.0.0'
        });

        if (connection.type === 'postgresql') {
          values.push(`($${j * 6 + 1}, $${j * 6 + 2}, $${j * 6 + 3}, $${j * 6 + 4}, $${j * 6 + 5}, $${j * 6 + 6})`);
        } else {
          values.push(`(?, ?, ?, ?, ?, ?)`);
        }
      }

      const insertQuery = `
        INSERT INTO perf_test_projects (name, description, status, priority, metadata, created_at)
        VALUES ${values.join(', ')}
      `;

      const params = [];
      for (let j = 0; j < batchSize && (i + j) < size; j++) {
        const recordNum = i + j + 1;
        params.push(
          `Project ${recordNum}`,
          `Description for project ${recordNum}`,
          recordNum % 4 === 0 ? 'completed' : 'active',
          recordNum % 5 + 1,
          JSON.stringify({
            category: `category_${recordNum % 10}`,
            tags: [`tag_${recordNum % 5}`, `tag_${recordNum % 7}`],
            priority: recordNum % 5 + 1,
            version: '1.0.0'
          }),
          new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000)
        );
      }

      await connection.query(insertQuery, params);
    }
  }

  async function measureQueryPerformance(
    connection: DatabaseConnection,
    queryText: string,
    queryType: string,
    parameters: any[] = []
  ): Promise<DatabasePerformanceResult> {
    const connectStart = performance.now();
    const connectionInfo = await connection.getConnectionInfo();
    const connectionTime = performance.now() - connectStart;

    const startTime = performance.now();
    const startMemory = process.memoryUsage();

    const result = await connection.query(queryText, parameters);
    const executionPlan = await connection.getExecutionPlan(queryText);

    const endTime = performance.now();
    const endMemory = process.memoryUsage();

    return {
      database: connection.type,
      queryType,
      executionTime: endTime - startTime,
      cpuTime: 0, // Would be extracted from database statistics
      memoryUsage: endMemory.heapUsed - startMemory.heapUsed,
      ioOperations: 0, // Would be extracted from database statistics
      rowsProcessed: result.length,
      planComplexity: executionPlan.length,
      indexesUsed: extractIndexesFromPlan(executionPlan, connection.type),
      connectionTime
    };
  }

  function extractIndexesFromPlan(plan: any[], dbType: 'postgresql' | 'oracle'): string[] {
    if (dbType === 'postgresql') {
      return plan
        .filter(step => step.operation?.includes('Index'))
        .map(step => step.index_name)
        .filter(Boolean);
    } else {
      return plan
        .filter(step => step.operation?.includes('INDEX'))
        .map(step => step.object_name)
        .filter(Boolean);
    }
  }

  async function compareQueryPerformance(
    queryText: string,
    queryType: string,
    parameters: any[] = [],
    oracleQuery?: string // Different query if Oracle syntax differs
  ): Promise<PerformanceComparison> {
    const postgresResult = await measureQueryPerformance(
      postgresConnection,
      queryText,
      queryType,
      parameters
    );

    const oracleResult = await measureQueryPerformance(
      oracleConnection,
      oracleQuery || queryText,
      queryType,
      parameters
    );

    const performanceRatio = oracleResult.executionTime / postgresResult.executionTime;
    const meetsBenchmark = performanceRatio <= 1.5; // Oracle should be within 150% of PostgreSQL

    let recommendation = '';
    if (performanceRatio > 2.0) {
      recommendation = 'Oracle performance significantly slower - investigate query optimization';
    } else if (performanceRatio > 1.5) {
      recommendation = 'Oracle performance acceptable but could be improved';
    } else if (performanceRatio < 0.8) {
      recommendation = 'Oracle performing better than PostgreSQL';
    } else {
      recommendation = 'Oracle performance meets benchmark requirements';
    }

    return {
      queryType,
      postgresqlResult: postgresResult,
      oracleResult: oracleResult,
      performanceRatio,
      recommendation,
      meetsBenchmark
    };
  }

  describe('Basic Query Performance Comparison', () => {
    it('should compare simple SELECT query performance', async () => {
      const comparison = await compareQueryPerformance(
        'SELECT * FROM perf_test_projects WHERE status = ? LIMIT 1000',
        'simple_select',
        ['active']
      );

      console.log('Simple SELECT comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.performanceRatio).toBeLessThan(1.5);
      expect(comparison.oracleResult.indexesUsed.length).toBeGreaterThan(0);
      expect(comparison.postgresqlResult.indexesUsed.length).toBeGreaterThan(0);
    });

    it('should compare pagination query performance', async () => {
      const pgQuery = 'SELECT * FROM perf_test_projects ORDER BY created_at DESC LIMIT 20 OFFSET 100';
      const oracleQuery = 'SELECT * FROM perf_test_projects ORDER BY created_at DESC OFFSET 100 ROWS FETCH NEXT 20 ROWS ONLY';

      const comparison = await compareQueryPerformance(
        pgQuery,
        'pagination',
        [],
        oracleQuery
      );

      console.log('Pagination comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.oracleResult.rowsProcessed).toBe(20);
      expect(comparison.postgresqlResult.rowsProcessed).toBe(20);
    });

    it('should compare JSON query performance', async () => {
      const pgQuery = `SELECT id, name FROM perf_test_projects WHERE metadata->>'category' = ? LIMIT 500`;
      const oracleQuery = `SELECT id, name FROM perf_test_projects WHERE JSON_VALUE(metadata, '$.category') = ? AND ROWNUM <= 500`;

      const comparison = await compareQueryPerformance(
        pgQuery,
        'json_query',
        ['category_5'],
        oracleQuery
      );

      console.log('JSON query comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.performanceRatio).toBeLessThan(2.0); // JSON operations may be slower in Oracle
    });
  });

  describe('Complex Query Performance Comparison', () => {
    it('should compare aggregation query performance', async () => {
      const query = `
        SELECT
          status,
          COUNT(*) as count,
          AVG(priority) as avg_priority,
          MIN(created_at) as first_created,
          MAX(created_at) as last_created
        FROM perf_test_projects
        WHERE created_at >= ?
        GROUP BY status
        ORDER BY count DESC
      `;

      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const comparison = await compareQueryPerformance(
        query,
        'aggregation',
        [thirtyDaysAgo]
      );

      console.log('Aggregation comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.oracleResult.rowsProcessed).toBeGreaterThan(0);
      expect(comparison.postgresqlResult.rowsProcessed).toBeGreaterThan(0);
    });

    it('should compare window function performance', async () => {
      const pgQuery = `
        SELECT
          id,
          name,
          status,
          ROW_NUMBER() OVER (PARTITION BY status ORDER BY created_at DESC) as row_num,
          LAG(created_at) OVER (ORDER BY created_at) as prev_created
        FROM perf_test_projects
        WHERE created_at >= ?
        LIMIT 1000
      `;

      const oracleQuery = `
        SELECT * FROM (
          SELECT
            id,
            name,
            status,
            ROW_NUMBER() OVER (PARTITION BY status ORDER BY created_at DESC) as row_num,
            LAG(created_at) OVER (ORDER BY created_at) as prev_created
          FROM perf_test_projects
          WHERE created_at >= ?
        ) WHERE ROWNUM <= 1000
      `;

      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const comparison = await compareQueryPerformance(
        pgQuery,
        'window_functions',
        [thirtyDaysAgo],
        oracleQuery
      );

      console.log('Window functions comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.performanceRatio).toBeLessThan(2.0);
    });

    it('should compare full-text search performance', async () => {
      const pgQuery = `
        SELECT id, name, description
        FROM perf_test_projects
        WHERE name ILIKE ? OR description ILIKE ?
        LIMIT 100
      `;

      const oracleQuery = `
        SELECT id, name, description
        FROM perf_test_projects
        WHERE UPPER(name) LIKE UPPER(?) OR UPPER(description) LIKE UPPER(?)
        AND ROWNUM <= 100
      `;

      const searchTerm = '%project%';
      const comparison = await compareQueryPerformance(
        pgQuery,
        'text_search',
        [searchTerm, searchTerm],
        oracleQuery
      );

      console.log('Text search comparison:', comparison);

      // Text search might be slower without proper indexes
      expect(comparison.performanceRatio).toBeLessThan(3.0);
    });
  });

  describe('Bulk Operations Performance Comparison', () => {
    it('should compare bulk INSERT performance', async () => {
      const insertData = Array.from({ length: 1000 }, (_, i) => ({
        name: `Bulk Project ${i}`,
        description: `Bulk description ${i}`,
        status: 'active',
        priority: (i % 5) + 1,
        metadata: JSON.stringify({ bulk: true, index: i })
      }));

      const pgQuery = `
        INSERT INTO perf_test_projects (name, description, status, priority, metadata)
        VALUES ${insertData.map((_, i) => `($${i * 5 + 1}, $${i * 5 + 2}, $${i * 5 + 3}, $${i * 5 + 4}, $${i * 5 + 5})`).join(', ')}
      `;

      const oracleQuery = `
        INSERT ALL
        ${insertData.map(() => 'INTO perf_test_projects (name, description, status, priority, metadata) VALUES (?, ?, ?, ?, ?)').join(' ')}
        SELECT * FROM DUAL
      `;

      const pgParams = insertData.flatMap(item => [item.name, item.description, item.status, item.priority, item.metadata]);
      const oracleParams = insertData.flatMap(item => [item.name, item.description, item.status, item.priority, item.metadata]);

      const comparison = await compareQueryPerformance(
        pgQuery,
        'bulk_insert',
        pgParams,
        oracleQuery
      );

      console.log('Bulk INSERT comparison:', comparison);

      expect(comparison.performanceRatio).toBeLessThan(2.0);
    });

    it('should compare bulk UPDATE performance', async () => {
      const query = `
        UPDATE perf_test_projects
        SET priority = priority + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE status = ? AND priority < ?
      `;

      const comparison = await compareQueryPerformance(
        query,
        'bulk_update',
        ['active', 5]
      );

      console.log('Bulk UPDATE comparison:', comparison);

      expect(comparison.meetsBenchmark).toBe(true);
      expect(comparison.performanceRatio).toBeLessThan(1.5);
    });
  });

  describe('Connection and Resource Management Comparison', () => {
    it('should compare connection establishment time', async () => {
      const iterations = 10;
      const pgConnectionTimes: number[] = [];
      const oracleConnectionTimes: number[] = [];

      for (let i = 0; i < iterations; i++) {
        const pgStart = performance.now();
        const pgConn = await createDatabaseConnection('postgresql');
        pgConnectionTimes.push(performance.now() - pgStart);
        await pgConn.close();

        const oracleStart = performance.now();
        const oracleConn = await createDatabaseConnection('oracle');
        oracleConnectionTimes.push(performance.now() - oracleStart);
        await oracleConn.close();
      }

      const avgPgTime = pgConnectionTimes.reduce((a, b) => a + b, 0) / iterations;
      const avgOracleTime = oracleConnectionTimes.reduce((a, b) => a + b, 0) / iterations;
      const connectionRatio = avgOracleTime / avgPgTime;

      console.log('Connection time comparison:', {
        postgresql: avgPgTime,
        oracle: avgOracleTime,
        ratio: connectionRatio
      });

      expect(connectionRatio).toBeLessThan(2.0); // Oracle connection time should be reasonable
      expect(avgOracleTime).toBeLessThan(1000); // Should connect within 1 second
    });

    it('should compare concurrent query handling', async () => {
      const concurrentQueries = 20;
      const queryText = 'SELECT COUNT(*) FROM perf_test_projects WHERE status = ?';

      const pgPromises = Array.from({ length: concurrentQueries }, () =>
        measureQueryPerformance(postgresConnection, queryText, 'concurrent', ['active'])
      );

      const oraclePromises = Array.from({ length: concurrentQueries }, () =>
        measureQueryPerformance(oracleConnection, queryText, 'concurrent', ['active'])
      );

      const [pgResults, oracleResults] = await Promise.all([
        Promise.all(pgPromises),
        Promise.all(oraclePromises)
      ]);

      const avgPgTime = pgResults.reduce((sum, r) => sum + r.executionTime, 0) / concurrentQueries;
      const avgOracleTime = oracleResults.reduce((sum, r) => sum + r.executionTime, 0) / concurrentQueries;
      const concurrentRatio = avgOracleTime / avgPgTime;

      console.log('Concurrent query comparison:', {
        postgresql: avgPgTime,
        oracle: avgOracleTime,
        ratio: concurrentRatio,
        queries: concurrentQueries
      });

      expect(concurrentRatio).toBeLessThan(1.5);
      expect(pgResults.length).toBe(concurrentQueries);
      expect(oracleResults.length).toBe(concurrentQueries);
    });
  });

  describe('Performance Regression Detection', () => {
    it('should establish baseline performance metrics', async () => {
      const baselineQueries = [
        { query: 'SELECT * FROM perf_test_projects WHERE id = ?', params: [1000], type: 'point_select' },
        { query: 'SELECT * FROM perf_test_projects WHERE status = ? LIMIT 100', params: ['active'], type: 'filtered_select' },
        { query: 'SELECT COUNT(*) FROM perf_test_projects GROUP BY status', params: [], type: 'aggregation' },
        { query: 'SELECT * FROM perf_test_projects ORDER BY created_at DESC LIMIT 50', params: [], type: 'ordered_select' }
      ];

      const baselineResults: PerformanceComparison[] = [];

      for (const testQuery of baselineQueries) {
        const comparison = await compareQueryPerformance(
          testQuery.query,
          testQuery.type,
          testQuery.params
        );
        baselineResults.push(comparison);
      }

      console.log('Baseline performance metrics:', baselineResults);

      // Store baseline for future regression testing
      const baselineMetrics = {
        timestamp: new Date().toISOString(),
        testDataSize,
        results: baselineResults.map(r => ({
          queryType: r.queryType,
          performanceRatio: r.performanceRatio,
          oracleExecutionTime: r.oracleResult.executionTime,
          postgresqlExecutionTime: r.postgresqlResult.executionTime
        }))
      };

      // All baseline queries should meet performance requirements
      expect(baselineResults.every(r => r.meetsBenchmark)).toBe(true);
      expect(baselineResults.every(r => r.performanceRatio < 1.5)).toBe(true);
    });

    it('should detect performance anomalies', async () => {
      // Simulate a potentially problematic query
      const problematicQuery = `
        SELECT p1.*, p2.name as related_name
        FROM perf_test_projects p1
        CROSS JOIN perf_test_projects p2
        WHERE p1.priority = p2.priority
        AND p1.id != p2.id
        LIMIT 100
      `;

      const comparison = await compareQueryPerformance(
        problematicQuery,
        'cross_join',
        []
      );

      console.log('Anomaly detection result:', comparison);

      if (comparison.performanceRatio > 2.0) {
        console.warn(`Performance anomaly detected: Oracle is ${comparison.performanceRatio.toFixed(2)}x slower than PostgreSQL`);
        expect(comparison.recommendation).toContain('investigate');
      }

      // The test should complete even if performance is poor
      expect(comparison.oracleResult.executionTime).toBeGreaterThan(0);
      expect(comparison.postgresqlResult.executionTime).toBeGreaterThan(0);
    });
  });
});